<!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=6.0.4"><link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=6.0.4"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=6.0.4"><link rel="mask-icon" href="/favicon.ico?v=6.0.4" color="#222"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"6.0.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="keywords" content="分布式,一致性哈希,hash,"><meta name="description" content="哈希表的原理与实现一列键值对数据，存储在一个table中，如何通过数据的关键字快速查找相应值呢？不要告诉我一个个拿出来比较key啊，呵呵。  大家都知道，在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。"><meta name="keywords" content="分布式,一致性哈希,hash"><meta property="og:type" content="article"><meta property="og:title" content="（转）分布式一致性哈希环"><meta property="og:url" content="http://www.jerrylou.me/笔记/consistent-hash-intro-20170216.html"><meta property="og:site_name" content="Jerrylou&#39;s Notes"><meta property="og:description" content="哈希表的原理与实现一列键值对数据，存储在一个table中，如何通过数据的关键字快速查找相应值呢？不要告诉我一个个拿出来比较key啊，呵呵。  大家都知道，在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8mm5njj302j02w3ya.jpg"><meta property="og:image" content="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8pmms8j306i071dfr.jpg"><meta property="og:image" content="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8pvqxbj307v0710sr.jpg"><meta property="og:image" content="http://wx3.sinaimg.cn/mw690/0065glrAgy1fckd8q77v7j307v0713yj.jpg"><meta property="og:image" content="http://wx3.sinaimg.cn/mw690/0065glrAgy1fckd8qqwvlj307v071dfv.jpg"><meta property="og:image" content="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8rlgllj307v071jrf.jpg"><meta property="og:image" content="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8rhbcoj30ep06gq30.jpg"><meta property="og:image" content="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8s3sguj306s05bdg1.jpg"><meta property="og:image" content="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8mm5njj302j02w3ya.jpg"><meta property="og:image" content="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8pvqxbj307v0710sr.jpg"><meta property="og:updated_time" content="2018-06-29T10:03:09.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="（转）分布式一致性哈希环"><meta name="twitter:description" content="哈希表的原理与实现一列键值对数据，存储在一个table中，如何通过数据的关键字快速查找相应值呢？不要告诉我一个个拿出来比较key啊，呵呵。  大家都知道，在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。"><meta name="twitter:image" content="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8mm5njj302j02w3ya.jpg"><link rel="alternate" href="/atom.xml" title="Jerrylou's Notes" type="application/atom+xml"><link rel="canonical" href="http://www.jerrylou.me/笔记/consistent-hash-intro-20170216.html"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>（转）分布式一致性哈希环 | Jerrylou's Notes</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Jerrylou's Notes</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">labor for reward</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/resume.html" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jerrylou.me/笔记/consistent-hash-intro-20170216.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="luoji"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Jerrylou's Notes"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">（转）分布式一致性哈希环</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-16T09:38:38+08:00">2017-02-16</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/笔记/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a></span></span> <span id="/笔记/consistent-hash-intro-20170216.html" class="leancloud_visitors" data-flag-title="（转）分布式一致性哈希环"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="哈希表的原理与实现"><a href="#哈希表的原理与实现" class="headerlink" title="哈希表的原理与实现"></a>哈希表的原理与实现</h3><p>一列键值对数据，存储在一个table中，如何通过数据的关键字快速查找相应值呢？不要告诉我一个个拿出来比较key啊，呵呵。</p><p>大家都知道，在所有的线性数据结构中，数组的定位速度最快，因为它可通过数组下标直接定位到相应的数组空间，就不需要一个个查找。而哈希表就是利用数组这个能够快速定位数据的结构解决以上的问题的。</p><a id="more"></a><p>具体如何做呢？大家是否有注意到前面说的话：“数组可以通过下标直接定位到相应的空间”，对就是这句，哈希表的做法其实很简单，就是把Key通过一个固定的算法函数，既所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。</p><p>不知道说到这里，一些不了解的朋友是否大概了解了哈希表的原理，其实就是通过空间换取时间的做法。到这里，可能有的朋友就会问，哈希函数对key进行转换，取余的值一定是唯一的吗？这个当然不能保证，主要是由于hashcode会对数组长度进行取余，因此其结果由于数组长度的限制必然会出现重复，所以就会有“冲突”这一问题，至于解决冲突的办法其实有很多种，比如重复散列的方式，大概就是定位的空间已经存在value且key不同的话就重新进行哈希加一并求模数组元素个数，既 (h(k)+i) mod S , i=1,2,3…… ，直到找到空间为止。还有其他的方式大家如果有兴趣的话可以自己找找资料看看。</p><p>Hash表这种数据结构在java中是原生的一个集合对象，在实际中用途极广，主要有这么几个特点：</p><ol><li>访问速度快</li><li>大小不受限制</li><li>按键进行索引，没有重复对象</li><li>用字符串(id:string)检索对象(object)</li></ol><p>今天整理以前写的一些算法，翻出来一个hash表的实现，就贴出来，自己也温习温习。先看看头文件，也就是数据结构的定义，相当于java中的接口的概念：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    HASHSIZE 256</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义hash表中的节点的类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>   <span class="title">nlist</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>   <span class="title">nlist</span>    *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">char</span>   *name;</span><br><span class="line">    <span class="keyword">char</span>   *defn;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义接口中的函数，也就是对外来说，这个程序可以做什么</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span>    <span class="title">hash</span><span class="params">(<span class="keyword">char</span>*s)</span></span>;<span class="comment">//计算一个串的hash值</span></span><br><span class="line"><span class="function">struct   nlist    *<span class="title">lookup</span><span class="params">(<span class="keyword">char</span>*s)</span></span>;<span class="comment">//查找一个value，根据key</span></span><br><span class="line"><span class="function">struct   nlist    *<span class="title">install</span><span class="params">(<span class="keyword">char</span>*name,<span class="keyword">char</span>*defn)</span></span>;<span class="comment">//插入一个key=value的对象</span></span><br></pre></td></tr></table></figure><p></p><p>然后是具体实现：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"list.h"</span></span></span><br><span class="line"> </span><br><span class="line">staticstructnlist *hashtab[HASHSIZE];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span>    <span class="title">hash</span><span class="params">(<span class="keyword">char</span>*s)</span>  <span class="comment">//取得hash值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span>    hashval;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(hashval = <span class="number">0</span>; *s !=<span class="string">'\0'</span>;s++)</span><br><span class="line">            hashval = *s + <span class="number">31</span> * hashval;</span><br><span class="line">   returnhashval % HASHSIZE;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct   nlist    *<span class="title">lookup</span><span class="params">(<span class="keyword">char</span>*s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">nlist</span>    *<span class="title">np</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(np = hashtab[hash(s)]; np != <span class="literal">NULL</span>; np = np-&gt;next)</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,np-&gt;name) == <span class="number">0</span>)</span><br><span class="line">           returnnp;</span><br><span class="line">   returnNULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">struct   nlist    *<span class="title">install</span><span class="params">(<span class="keyword">char</span>*name,<span class="keyword">char</span>*defn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span>   <span class="title">nlist</span>    *<span class="title">np</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span>    hashval;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>((np = lookup(name)) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        np = (structnlist *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structnlist));</span><br><span class="line">       <span class="keyword">if</span>(np == <span class="literal">NULL</span> || (np-&gt;name = strdup(name)) == <span class="literal">NULL</span>)</span><br><span class="line">               returnNULL;</span><br><span class="line">        hashval = hash(name);</span><br><span class="line">        np-&gt;next= hashtab[hashval];</span><br><span class="line">        hashtab[hashval] = np;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">       <span class="built_in">free</span>((<span class="keyword">void</span>*)np-&gt;defn);</span><br><span class="line">   <span class="keyword">if</span>((np-&gt;defn = strdup(defn)) == <span class="literal">NULL</span>)</span><br><span class="line">           returnNULL;</span><br><span class="line">   returnnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>很简单，只有两个外部接口，</p><ol><li>install(key, value),用来插入一个新的节点</li><li>lookup(key),根据一个键来进行搜索，并返回节点</li></ol><p>代码很简单，主要用到的hash算法跟java中的String的hashcode()方法中用到的算法一样，使用：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span>*s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span>    hashval;</span><br><span class="line">    <span class="keyword">for</span>(hashval = <span class="number">0</span>; *s !=<span class="string">'\0'</span>;s++)</span><br><span class="line">        hashval = *s + <span class="number">31</span> * hashval;</span><br><span class="line">    returnhashval % HASHSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h3><p>consistent hashing 一致性 hash 算法早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在 cache 系统中应用越来越广泛。</p><h4 id="基本场景"><a href="#基本场景" class="headerlink" title="基本场景"></a>基本场景</h4><p>比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache： hash(object)%N</p><p>一切都运行正常，再考虑如下的两种情况：</p><ol><li>一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；</li><li>由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；</li></ol><p>1 和 2 意味着什么？这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；</p><p>再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。有什么方法可以改变这个状况呢，这就是 consistent hashing 一致性 hash 算法…</p><h4 id="hash算法和单调性"><a href="#hash算法和单调性" class="headerlink" title="hash算法和单调性"></a>hash算法和单调性</h4><p>Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：</p><p>单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</p><p>容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。</p><h4 id="consistent-hashing-算法的原理"><a href="#consistent-hashing-算法的原理" class="headerlink" title="consistent hashing 算法的原理"></a>consistent hashing 算法的原理</h4><p>consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。</p><p>下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。</p><ul><li>第一步环形hash 空间<br>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下图所示的那样。</li></ul><p><img src="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8mm5njj302j02w3ya.jpg" alt="Alt text" title="图"></p><ul><li>第二步把对象映射到hash 空间<br>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如下图所示。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(object1) = key1;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">hash</span>(object4) = key4;</span><br></pre></td></tr></table></figure><p><img src="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8pmms8j306i071dfr.jpg" alt="Alt text" title="图"><br>4 个对象的 key 值分布</p><ul><li>第三步把cache 映射到hash 空间</li></ul><p>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hash</span>(cache A) = key A;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">hash</span>(cache C) = key C;</span><br></pre></td></tr></table></figure><p><img src="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8pvqxbj307v0710sr.jpg" alt="Alt text" title="图"><br>cache 和对象的 key 值分布<br>说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash 输入。</p><ul><li>第四步把对象映射到cache</li></ul><p>现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。</p><p>在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！</p><p>依然继续上面的例子（上图），那么根据上面的方法：</p><ol><li>对象 object1 将被存储到 cache A 上；</li><li>object2和 object3 对应到 cache C ；</li><li>object4 对应到 cache B。</li></ol><ul><li>第五步考察cache 的变动</li></ul><p>前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。</p><p>考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。</p><p>因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可：<br><img src="http://wx3.sinaimg.cn/mw690/0065glrAgy1fckd8q77v7j307v0713yj.jpg" alt="Alt text" title="图"></p><p>Cache B 被移除后的 cache 映射<br>再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和 object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。</p><p>因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上：</p><p><img src="http://wx3.sinaimg.cn/mw690/0065glrAgy1fckd8qqwvlj307v071dfv.jpg" alt="Alt text" title="添加 cache D 后的映射关系图"></p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：</p><p>平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</p><p>hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了 object2 、 object3 和 object4 ；分布是很不均衡的。</p><p>为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：</p><p>“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。</p><p>仍以仅部署 cache A 和 cache C 的情况为例，在前面 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见下图 。</p><p><img src="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8rlgllj307v071jrf.jpg" alt="Alt text" title="引入“虚拟节点”后的映射关系图"></p><p>此时，对象到“虚拟节点”的映射关系为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objec1-&gt;cache A2</span><br><span class="line">objec2-&gt;cache A1</span><br><span class="line">objec3-&gt;cache C1</span><br><span class="line">objec4-&gt;cache C2</span><br></pre></td></tr></table></figure><p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图 7 所示。</p><p><img src="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8rhbcoj30ep06gq30.jpg" alt="Alt text" title="查询对象所在 cache图"></p><p>“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为 202.168.14.241 。</p><p>引入“虚拟节点”前，计算 cache A 的 hash 值：Hash(“202.168.14.241”);<br>引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hash(<span class="string">"202.168.14.241#1"</span>); // cache A1</span><br><span class="line">Hash(<span class="string">"202.168.14.241#2"</span>); // cache A2</span><br></pre></td></tr></table></figure><p><strong>小结</strong><br>Consistent hashing 的基本原理就是这些，具体的分布性等理论分析应该是很复杂的，不过一般也用不到。</p><h3 id="分布式哈希算法"><a href="#分布式哈希算法" class="headerlink" title="分布式哈希算法"></a>分布式哈希算法</h3><p>我们从浅入深一步一步介绍什么是分布式哈希表。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数是一种计算方法，它可以把一个值A映射到一个特定的范围[begin, end]之内。对于一个值的集合{k1, k2, … , kN}，哈希函数把他们均匀的映射到某个范围之中。这样，通过这些值就可以很快的找到与之对应的映射地址{index1, index2, … , indexN}。对于同一个值，哈希函数要能保证对这个值的运算结果总是相同的。</p><p><img src="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8s3sguj306s05bdg1.jpg" alt="Alt text" title="图"></p><p>哈希函数需要经过精心设计才能够达到比较好的效果，但是总是无法达到理想的效果。多个值也许会映射到同样的地址上。这样就会产生冲突，如图中的红线所示。在设计哈希函数时要尽量减少冲突的产生。</p><p>最简单的哈希函数就是一个求余运算： hash(A) = A % N。这样就把A这个值映射到了[0~N-1]这样一个范围之中。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表的核心就是哈希函数hash()。</p><p>哈希表是一中数据结构，它把KEY 和 VALUE用某种方式对应起来。使用hash()函数把一个KEY值映射到一个index上，即hash(KEY) = index。这样就可以把一个KEY值同某个index对应起来。然后把与这个KEY值对应的VALUE存储到index所标记的存储空间中。这样，每次想要查找KEY所对应的VALUE值时，只需要做一次hash()运算就可以找到了。</p><p>举个例子：图书馆中的书会被某人借走，这样“书名”和“人名”之间就形成了KEY与VALUE的关系。假设现在有三个记录：</p><table><thead><tr><th style="text-align:left">简明现代魔法</th><th style="text-align:left">小明</th></tr></thead><tbody><tr><td style="text-align:left">最后一天</td><td style="text-align:left">小红</td></tr><tr><td style="text-align:left">变形记</td><td style="text-align:left">小红</td></tr></tbody></table><p>这就是“书名”和“人名”的对应关系，它表示某人借了某本书。现在我们把这种对应关系用哈希表存储起来，它们的hash()值分别为：</p><table><thead><tr><th style="text-align:left">hash(简明现代魔法) = 2</th></tr></thead><tbody><tr><td style="text-align:left">hash(最后一天) = 0</td></tr><tr><td style="text-align:left">hash(变形记) = 1</td></tr></tbody></table><p>然后我们就可以在一个表中存储“人名”了：</p><table><thead><tr><th style="text-align:left">0</th><th style="text-align:left">小明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">小红</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">小红</td></tr></tbody></table><p>这三个人名分别存储在0、1和2号存储空间中。当我们想要查找《简明现代魔法》这本书是被谁借走的时候，只要hash()一下这个书名，就可以找到它所对应的index，为2。然后在这个表中就可以找到对应的人名了。在这里，KEY为“书名”， VALUE为“人名”。</p><p>当有大量的KEY VALUE对应关系的数据需要存储时，这种方法就非常有效。</p><h4 id="分布式哈希表"><a href="#分布式哈希表" class="headerlink" title="分布式哈希表"></a>分布式哈希表</h4><p>哈希表把所有的东西都存储在一台机器上，当这台机器坏掉了之后，所存储的东西就全部消失了。分布式哈希表可以把一整张哈希表分成若干个不同的部分，分别存储在不同的机器上，这样就降低了数据全部被损坏的风险。</p><p>分布式哈希表通常采用一致性哈希函数来对机器和数据进行统一运算。这里先不用深究一致性哈希究竟是什么，只需要知道它是对机器（通常是其IP地址）和数据（通常是其KEY值）进行统一的运算，把他们全都映射到一个地址空间中。假设有一个一致性哈希函数可以把一个值映射到32bit的地址空间中，从0一直到2^32 – 1。我们用一个圆环来表示这个地址空间。<br><img src="http://wx4.sinaimg.cn/mw690/0065glrAgy1fckd8mm5njj302j02w3ya.jpg" alt="Alt text" title="图"></p><p>假设有N台机器，那么hash()就会把这N台机器映射到这个环的N个地方。然后我们把整个地址空间进行一下划分，使每台机器控制一个范围的地址空间。这样，当我们向这个系统中添加数据的时候，首先使用hash()函数计算一下这个数据的index，然后找出它所对应的地址在环中属于哪个地址范围，我们就可以把这个数据放到相应的机器上。这样，就把一个哈希表分布到了不同的机器上。如下图所示：<br><img src="http://wx1.sinaimg.cn/mw690/0065glrAgy1fckd8pvqxbj307v0710sr.jpg" alt="Alt text" title="图"></p><p>这里蓝色的圆点表示机器，红色的圆点表示某个数据经过hash()计算后所得出的地址。</p><p>在这个图中，按照逆时针方向，每个机器占据的地址范围为从本机器开始一直到下一个机器为止。用顺时针方向来看，每个机器所占据的地址范围为这台机器之前的这一段地址空间。图中的虚线表示数据会存储在哪台机器上。</p><p>哈希表的工作原理与常用操作</p><p>哈希表（Hash Table）的应用近两年才在NOI中出现，作为一种高效的数据结构，它正在竞赛中发挥着越来越重要的作用。</p><p>哈希表最大的优点，就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。</p><p>哈希表又叫做散列表，分为“开散列” 和“闭散列”。考虑到竞赛时多数人通常避免使用动态存储结构，本文中的“哈希表”仅指“闭散列”，关于其他方面读者可参阅其他书籍。</p><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素。也可以简单的理解为，按照关键字为每一 个元素“分类”，然后将这个元素存储在相应“类”所对应的地方。</p><p>但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了“冲突”，换句话说，就是把不同的元素分在了相同的“类”之中。后面我们将看到一种解决“冲突”的简便做法。</p><p>总的来说，“直接定址”与“解决冲突”是哈希表的两大特点。</p><p>函数构造：构造函数的常用方法（下面为了叙述简洁，设 h(k) 表示关键字为 k 的元素所对应的函数值）：</p><ul><li>除余法： 选择一个适当的正整数 p ，令 h(k ) = k mod p ，这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。</li><li>数字选择法： 如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。</li></ul><p>冲突处理：线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i=1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。</p><p>支持运算：哈希表支持的运算主要有：初始化(makenull)、哈希函数值的运算(h(x))、插入元素(insert)、查找元素(member)。 设插入的元素的关键字为 x ，A 为存储的数组。 初始化比较容易，例如 ：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constempty=maxlongint;// 用非常大的整数代表这个位置没有存储元素</span><br><span class="line">p=9997;// 表的大小</span><br><span class="line">procedure makenull;</span><br><span class="line">var i:<span class="built_in">integer</span>;</span><br><span class="line">begin</span><br><span class="line">fori:=0 to p-1do</span><br><span class="line">A[i]:=empty;</span><br><span class="line">End;</span><br></pre></td></tr></table></figure><p></p><p>哈希函数值的运算根据函数的不同而变化，例如除余法的一个例子：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> h(x:longint):Integer;</span><br><span class="line">begin</span><br><span class="line">h:= x mod p;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>我们注意到，插入和查找首先都需要对这个元素定位，即如果这个元素若存在，它应该存储在什么位置，因此加入一个定位的函数 locate。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> locate(x:longint):<span class="built_in">integer</span>;</span><br><span class="line">var orig,i:<span class="built_in">integer</span>;</span><br><span class="line">begin</span><br><span class="line">orig:=h(x);</span><br><span class="line">i:=0;</span><br><span class="line"><span class="keyword">while</span>(i &lt; S)and(A[(orig+i)mod S]&lt;&gt;x)and(A[(orig+i)mod S]&lt;&gt;empty)<span class="keyword">do</span></span><br><span class="line">inc(i);</span><br><span class="line">//当这个循环停下来时，要么找到一个空的存储单元，要么找到这个元</span><br><span class="line">//素存储的单元，要么表已经满了</span><br><span class="line">locate:=(orig+i) mod S;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>插入元素：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procedure insert(x:longint);</span><br><span class="line">var posi:<span class="built_in">integer</span>;</span><br><span class="line">begin</span><br><span class="line">posi:=locate(x);//定位函数的返回值</span><br><span class="line">ifA[posi]=empty <span class="keyword">then</span> A[posi]:=x</span><br><span class="line">elseerror;//error 即为发生了错误，当然这是可以避免的</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>查找元素是否已经在表中：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">procedure member(x:longint):boolean;</span><br><span class="line">var posi:<span class="built_in">integer</span>;</span><br><span class="line">begin</span><br><span class="line">posi:=locate(x);</span><br><span class="line">ifA[posi]=x <span class="keyword">then</span> member:=<span class="literal">true</span></span><br><span class="line">elsemember:=<span class="literal">false</span>;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure><p></p><p>这些就是建立在哈希表上的常用基本运算。</p><p>当数据规模接近哈希表上界或者下界的时候，哈希表完全不能够体现高效的特点，甚至还不如一般算法。但是如果规模在中央，它高效的特点可以充分体现。试验表明当元素充满哈希表的 90% 的时候，效率就已经开始明显下降。这就给了我们提示：如果确定使用哈希表，应该尽量使数组开大，但对最太大的数组进行操作也比较费时间，需要找到一个平衡点。通常使它的容量至少是题目最大需求的 120% ，效果比较好（这个仅仅是经验，没有严格证明）。</p><h4 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h4><p>什么时候适合应用哈希表呢？如果发现解决这个问题时经常要询问：“某个元素是否在已知集合中？”，也就是需要高效的数据存储和查找，则使用哈希表是最好不过的了！那么，在应用哈希表的过程中，值得注意的是什么呢？</p><p>哈希函数的设计很重要。一个不好的哈希函数，就是指造成很多冲突的情况，从前面的例子已经可以看出来，解决冲突会浪费掉大量时间，因此我们的目标就是尽力避免冲突。前面提到，在使用“除余法”的时候，h(k)=k mod p ，p 最好是一个大素数。这就是为了尽力避免冲突。为什么呢？假设 p=1000 ，则哈希函数分类的标准实际上就变成了按照末三位数分类，这样最多1000类，冲突会很多。一般地说，如果 p 的约数越多，那么冲突的几率就越大。</p><p>简单的证明：假设 p 是一个有较多约数的数，同时在数据中存在 q 满足 gcd(p,q)=d &gt;1 ，即有 p=a<em>d , q=b</em>d, 则有 q mod p= q – p <em>[q div p] =q – p</em>[b div a] . ① 其中 [b div a ] 的取值范围是不会超过 [0，b] 的正整数。也就是说， [b div a] 的值只有 b+1 种可能，而 p 是一个预先确定的数。因此 ① 式的值就只有 b+1 种可能了。这样，虽然mod 运算之后的余数仍然在 [0，p-1] 内，但是它的取值仅限于 ① 可能取到的那些值。也就是说余数的分布变得不均匀了。容易看出， p 的约数越多，发生这种余数分布不均匀的情况就越频繁，冲突的几率越高。而素数的约数是最少的，因此我们选用大素数。记住“素数是我们的得力助手”。</p><p>另一方面，一味的追求低冲突率也不好。理论上，是可以设计出一个几乎完美，几乎没有冲突的函数的。然而，这样做显然不值得，因为这样的函数设计 很浪费时间而且编码一定很复杂，与其花费这么大的精力去设计函数，还不如用一个虽然冲突多一些但是编码简单的函数。因此，函数还需要易于编码，即易于实现。</p><p>综上所述，设计一个好的哈希函数是很关键的。而“好”的标准，就是较低的冲突率和易于实现。</p><p>另外，使用哈希表并不是记住了前面的基本操作就能以不变应万变的。有的时候，需要按照题目的要求对哈希表的结构作一些改进。往往一些简单的改进就可以带来巨大的方便。</p><p>这些只是一般原则，真正遇到试题的时候实际情况千变万化，需要具体问题具体分析才行。</p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/分布式/" rel="tag"># 分布式</a> <a href="/tags/一致性哈希/" rel="tag"># 一致性哈希</a> <a href="/tags/hash/" rel="tag"># hash</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/redis/redis-cache-backup-20170212.html" rel="next" title="基于Redis Cluster的分布式缓存备份篇（七）"><i class="fa fa-chevron-left"></i> 基于Redis Cluster的分布式缓存备份篇（七）</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/笔记/deluge-install-ubuntu-20170218.html" rel="prev" title="Ubuntu16 tls安装自己的Bit下载工具Deluge">Ubuntu16 tls安装自己的Bit下载工具Deluge<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div id="gitalk-container"></div><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="luoji"><p class="site-author-name" itemprop="name">luoji</p><p class="site-description motion-element" itemprop="description">点滴生活 乐在其中</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">71</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">19</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">118</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/gunsluo" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://git.oschina.net/gunsluo" target="_blank" title="OsChina" rel="external nofollow"><i class="fa fa-fw fa-code"></i> OsChina</a></span><span class="links-of-author-item"><a href="https://twitter.com/gunsluo" target="_blank" title="Twitter" rel="external nofollow"><i class="fa fa-fw fa-twitter"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.facebook.com/gunsluo" target="_blank" title="Facebook" rel="external nofollow"><i class="fa fa-fw fa-facebook"></i> Facebook</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表的原理与实现"><span class="nav-number">1.</span> <span class="nav-text">哈希表的原理与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性hash算法"><span class="nav-number">2.</span> <span class="nav-text">一致性hash算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本场景"><span class="nav-number">2.1.</span> <span class="nav-text">基本场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hash算法和单调性"><span class="nav-number">2.2.</span> <span class="nav-text">hash算法和单调性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#consistent-hashing-算法的原理"><span class="nav-number">2.3.</span> <span class="nav-text">consistent hashing 算法的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟节点"><span class="nav-number">2.4.</span> <span class="nav-text">虚拟节点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式哈希算法"><span class="nav-number">3.</span> <span class="nav-text">分布式哈希算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希函数"><span class="nav-number">3.1.</span> <span class="nav-text">哈希函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希表"><span class="nav-number">3.2.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式哈希表"><span class="nav-number">3.3.</span> <span class="nav-text">分布式哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基础操作"><span class="nav-number">3.4.</span> <span class="nav-text">基础操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用举例"><span class="nav-number">3.5.</span> <span class="nav-text">应用举例</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">luoji</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript">
        const gitalk = new Gitalk({
          clientID: 'a08a92a93c341ccd90ca',
          clientSecret: '6cde4abcd0c6a6df7b8ee32f0d2205953aa86b89',
          repo: 'gunsluo.github.io',
          owner: 'gunsluo',
          admin: 'gunsluo'.split(','),
          pagerDirection: 'first',
          id: md5(location.pathname),
          // facebook-like distraction free mode
          distractionFreeMode: false
        })
        gitalk.render('gitalk-container')
      </script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("EIRSFQCtgqHK7eaOtlKs0umf-gzGzoHsz","9myi3PwxM16hJ5efRBQhTaXf")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var i=0;i<e.length;i++){var s=e[i],r=s.get("url"),l=s.get("time"),c=document.getElementById(r);$(c).find(t).text(l)}for(i=0;i<n.length;i++){r=n[i],c=document.getElementById(r);var u=$(c).find(t);""==u.text()&&u.text(0)}}else o.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){$(document.getElementById(n)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var s=new e,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),s.setACL(r),s.set("title",o),s.set("url",n),s.set("time",1),s.save(null,{success:function(e){$(document.getElementById(n)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script></body></html>